## v8垃圾回收机制

### 1.基础部分

### 1.1 为什么会有垃圾回收

JS设计时比较简单，只是为了在浏览器运行，不是可持续化的代码，认为不会占用过多的内存

随着后续的发展 Node 也是使用v8，因为服务是持久性的，比如有上传大文件>2GB的情况，此时我们需要关注内存的情况

v8引擎替我们封装好了根据当前定义对象大小自动申请分配内存，所以不需要我们手动管理内存，自然要有垃圾回收的机制，否则只分配不回收，没多久内存就会被占满，导致应用崩溃

### 1.2 什么情况会造成内存泄漏

- 循环引用
- 使用了过多的闭包
- 定义过多全局变量（全局变量不会被垃圾回收，始终存活到程序运行结束，在全局变量使用完毕后将其设置为null，才会触发回收机制）
- 定时器/事件监听没有被清除

### 2.v8引擎内存部分

- Stack：栈
- Heap memory：堆
    - new space 新生代空间
    - old space 新生代空间
    - Large Object space 大对象空间（大于其它空间大小限制对象存放的位置）
    - Code space 代码运行空间
    - Cell space
    - Property cell space
    - Map cell space


#### 2.1 内存的限制

在64位系统下最多可以使用1.4GB（1464MB）的内存，32位为0.7G（732MB）

64位：新生代空间为64MB，老生代为1400MB

32位：新生代空间为32MB，老生代为700MB

node >= 14 的内存为2GB（node深入浅出）

* 为什么要把v8内存限制在1.4G呢？

    是v8引擎设计之初，只是做为JS的执行环境，在浏览器端和很少会遇到使用大量内存的场景，因此也就没有必要把内存设置得过高

因为JS是单线程的，那么也就意味着在进行垃圾回收时，主线程进入暂停的状态，直到垃圾回收结束后才会继续执行主线程的逻辑

垃圾回收本身也是件非常耗时的事情，如果清理内存为1.5G的垃圾，那么需要50ms以上的时间。如果有动画的话，可能会造成动画卡顿、掉帧

* 查看内存分配情况

浏览器中可以通过 window.performance 查看内存分配情况

node环境中可以使用 process.memoryUsage() 查看内存分配情况

```
rss: 20762624,       // 驻留集大小：所有内存占用，包括指令区和堆栈
heapTotal: 5005312,  // 堆内存总占用
heapUsed: 3195408,   // 已经使用的堆内存
external: 1080631,   // 额外内存(可以扩展)
```

* 设置内存上限

```
// 设置新生代内存中单个半空间的内存最小值，单位MB
node --min-semi-space-size=1024 xxx.js

// 设置新生代内存中单个半空间的内存最大值，单位MB
node --max-semi-space-size=1024 xxx.js

// 设置老生代内存最大值，单位MB
node --max-old-space-size=2048 xxx.js
```

> 内存限制只能接收你的空闲内存的75%，所以最好使用 os.freemem / 0.75 测试一下自己可以使用的内存有多少

### 3. 垃圾回收机制

垃圾回收的过程主要出现在新生代和老生代

新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象

对象最开始都会被分配到新生代空间，如果新生代空间内存不够会直接分配到老生代空间，新生代中的对象也会在满足某种条件后，晋升到老生代空间

#### 3.1 新生代空间

新生代空间被等分成两个部分：semi space form、semi space to，to空间也可以理解为active new space（未被激活区域）

既然是等分为两个部分，那么他们在64位系统下，各自的内存为32MB，在32位下为16MB

新生代空间采用Scavenge垃圾回收算法，可以理解为copy的操作

- Scavenge算法主要采用Cheney算法，被等分的两个空间只有一个空间处于使用状态，另一个是闲置状态

- 声明的对象首先会被分配到from空间，当进行垃圾回收时，如果from空间有存活对象，则会被复制到to空间保存，非存活的对象会被自动回收
  
- 当复制完成后，form空间和to空间会角色互换，to空间会变成新的from空间，原来的from空间则变为to空间

这种操作缺点也很明显，就是有一半的空间被浪费了，所以Scavenge是典型的牺牲空间换时间的算法。但是Scavenge是非常适合新生代空间的，因为新生代空间的存活时间较短，而且被浪费掉的内存占用并不多（32MB或16MB）


#### 3.2 空间晋升

当一个对象经历过多次复制依然存活，那么它会认为是一个生命周期较长的对象，那么在下一次垃圾回收时，该对象会被转移到老生代空间，这种转移就叫做晋升，对象晋升的条件有两个

- 对象已经经历过一次Scavenge算法
- To空间的内存占比已经超过25%


#### 3.3 老生代空间

老生代中，不再适合Scavenge算法，因为内存占比过大，浪费一半内存成本会比较高，所以采用新的算法
Mark-Sweep（标记清除）和 Mark-Compact（标记整理）

Mark-Sweep（标记清除）分为标记和清除两个阶段

1. 标记：从根节点出发进行广度扫描，标记可以被访问到的变量，根节点不能访问到的被视为垃圾
2. 清除：清除标记的垃圾

    根节点并为指window/global，以下几种情况都可以做为根节点

        1. 全局对象 
        2. 本地函数的局部变量和参数
        3. 当前嵌套调用链上的其它函数的变量和参数

此算法存在一个问题，就是在经历过一次标记清除后，内存空间可能会存在不连续的状态，所以后面如果需要分配一个内存，而剩余的碎片空间不够的话，就会提前出发垃圾回收，而此次回收是不必要的


为了解决 Mark-Sweep 的问题，就有了 Mark-Compact（标记整理），面标记整理分为标记、整理、清除三个阶段

1. 标记：广度扫描
2. 整理：将活跃的内存往前移动（移动过程中会覆盖原有的垃圾的位置）
3. 清除：一次性清除活跃内存后面的所有垃圾

而Mark-Compact 的缺点则是因为需要移动，所以执行时间不会很快，所以在V8的回收策略中，Mark-Sweep 和Mark-Compact 是结合使用的

主要使用 Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用 Mark-Cpmpact 进行整理清除


老生代的标记过程分为两种：

- 全停顿标记(stop-the-world)

因为JS是单线程机制，一次性进行广度扫描时时间会很久，影响主进程的时间，因为为了减少垃圾回收的停顿时间，v8引入了增量标记(Incremental Marking)的概念

- 增量标记+三色标记法

1. 从根节点进行扫描 -> 将当前节点置灰 -> 将当前节点下有关联的节点置黑（表示下次需要标记的区域）
2. 扫描上次置黑的区域 -> 将置黑的部分置灰 -> 将开始进入的黑色区域置白

所以后续进入标记过程时会从置黑的节点开始进行扫描，不需要每次从根节点进行扫描


* 补充：引用计数

早期浏览器使用引用计数的方式，就是查看对象是否要有其它引用指向它，如果没有指向该对象的引用，就为被视为垃圾，但是如果是循环引用的场景就会无法被回收，截至2012年，所有浏览器均放弃了这种算法，现在改为标记清除和标记整理的方式


#### 扩展部分

* 全局变量始终存活到程序运行结束，无法被垃圾回收机制回收，而局部变量当程序执行且没有被引用时会被标记会垃圾，在内存不够时触发垃圾回收机制时会被清除
